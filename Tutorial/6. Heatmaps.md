# 6. Heatmaps
In this part of the tutorial you will learn what heatmaps are, for what they can be used, and how to use heatmaps in MapBox.
## 6.1 What is a heatmap
Heatmap is simply anything that ties "heat" to visual property. Heat does not need to be actual temperature heat value, it can be any other data maped to color, size, transparency etc. scale. These are all examples of what can be considered heatmap:  
Map of temperatures:  
![image](https://github.com/dpastierovic/Geospatial-Application/assets/18383754/e3b11a8c-d8d5-4908-a34d-9772248d0a64)  
Map of clouds:
![image](https://github.com/dpastierovic/Geospatial-Application/assets/18383754/c80ffe3a-3bcc-49b1-8239-d92b1c08d414)  
Map of bear population based on density:
![image](https://github.com/dpastierovic/Geospatial-Application/assets/18383754/f0d76013-f59e-47ff-951f-6ee7588d075c)  
Areas colored by number of user interactions on a website:
![image](https://github.com/dpastierovic/Geospatial-Application/assets/18383754/e6cad979-e9da-422c-9c60-8a76451e06f7)  
  
As you can see, posible uses are really varied. Most obvious is to display some kind of data that is already tied to locations on map and change color based on "heat". But there are other useful uses for reports and analysis, like heatmap of user clicks on the webpage. Thanks to this heatmap, you can easily present to non-technical people what is used most and, for example, which parts of the page are candidates for performance optimization if they are used often, or for removal if they are not being used at all.
## 6.2 Grid style heatmap
We will not spend time here for heatmaps like that last one, displaying user interactions on webpage. This tutorial is focued on geospatial data. So in this part we will explore different posibilities how to create geospatial heatmaps. First step is to choose correct color scale. You should think about minimum and maximum values and asign them colors (or other property you want to change) that are different enough to be easily distinguishable. Then you should think about how to interpolate between these colors, or if you should add more colors in between and do more steps, for example like this:  
![image](https://github.com/dpastierovic/Geospatial-Application/assets/18383754/4862a7f3-9172-4c5c-a982-c428f7b52cfd)  
Correct color scale can greatly enhance readability of the heatmap, or make it difficult to read.  
  
Heatmap on the last image is first style of heatmap you can do with geospatial data. This is ideal for things such as weather readings and densities in areas. This is done by cutting the area where you want to display the heatmap into squares and asigning heat to each square based on value of the heat. We will do this for density of shops. Goal is to add new button next to the map in our web application that generates and displays heatmap for current map view. There will be number input to take width of squares in degrees that should be used. You can change it to meters but you will need to change units because PostGis is working in degrees.
First, we need to prepare new Api endpoint to get data from database to the web application. This time we want all shops in current map view. To pass map view, we need two oposing corners to make a square. Shops are in table planet_osm_point, and we will select anything that has non-null value in shop column. We need to take care of SRIDs here, because our coordinates of map view are in 4326 SRID but shop data are in 3857 SRID.
```sql
SELECT ST_Transform(way, 4326)
FROM planet_osm_point
WHERE ST_Contains(ST_MakeEnvelope(17, 48, 18, 49, 4326), ST_Transform(ST_SetSRID(way, 3857), 4326))
AND shop <> 'null'
```
Now we can use handy ST_SquareGrid function. This takes width of one square in degrees. For our purposes small numbers are needed, since entire Slovakia is only two degrees wide. Second parameter is geometry that should be put into one square of the grid. If other gometry sooner in query execution shared same grid it will create identical grid squares. Then we can use JOIN with ON ST_Intersects condition to pair our geometries with grid squares, and then COUNT together with GROUP BY geometry of squares to count how many shops are in each square. Then we can use json_agg, which aggregates its parameter, and ST_AsGeoJSON to create single geojson for the entire grid. Final query looks like this:
```sql
SELECT json_build_object('type', 'FeatureCollection', 'features', json_agg(ST_AsGeoJSON(t.*)::json)) as geojson
FROM
  (SELECT COUNT(*), squares.geom
    FROM (SELECT ST_Transform(way, 4326) as geom
          FROM planet_osm_point WHERE 
          ST_Contains(ST_MakeEnvelope(17, 48, 18, 48.5, 4326), ST_Transform(ST_SetSRID(way, 3857), 4326))
          AND shop <> 'null') as pts
    INNER JOIN
    ST_SquareGrid(0.05, geom) AS squares
    ON ST_Intersects(pts.geom, squares.geom)
  GROUP BY squares.geom) as t
```
Output of this query displayed in geometry viewer should look like this:  
![image](https://github.com/dpastierovic/Geospatial-Application/assets/18383754/2a8f2996-28df-4345-ae7f-9952be9426fb)  

Now we can use this query to add new methods to our OsmContext and OsmController. This is similar to what we did in part 3 of this tutorial. You can check it there, or solution is in this spoiler if you are struggling.

<details>
<summary>OsmContext.cs method</summary>

```cs
public async Task<string> GetShopsGridHeatMap(double latitude1, double longitude1, double latitude2, double longitude2, double gridWidth)
{
  await using var connection = _dataSource.CreateConnection();
  connection.Open();

  await using var command = new NpgsqlCommand(@$"
    SELECT json_build_object('type', 'FeatureCollection', 'features', json_agg(ST_AsGeoJSON(t.*)::json)) as geojson
      FROM
        (SELECT COUNT(*), squares.geom
          FROM (SELECT ST_Transform(way, 4326) as geom
                FROM planet_osm_point WHERE 
                ST_Contains(ST_MakeEnvelope({longitude1}, {latitude1}, {longitude2}, {latitude2}, 4326), ST_Transform(ST_SetSRID(way,                     3857), 4326))
                AND shop <> 'null') as pts
          INNER JOIN
          ST_SquareGrid({gridWidth}, geom) AS squares
          ON ST_Intersects(pts.geom, squares.geom)
        GROUP BY squares.geom) as t",
    connection);

  var reader = await command.ExecuteReaderAsync();

  var column = (await reader.GetColumnSchemaAsync()).FirstOrDefault(c => c.ColumnName == "geojson");
  if (column?.ColumnOrdinal == null)
  {
    return string.Empty;
  }

  await reader.ReadAsync();
  return reader.GetFieldValue<string>(column.ColumnOrdinal.Value);
}
```
</details>  

<details>
<summary>OsmController.cs method</summary>

```cs
[HttpGet(Name = "ShopsHeatMap")]
[ProducesResponseType(StatusCodes.Status200OK)]
public async Task<IActionResult> GetShopsHeatMap(
  [FromQuery] double latPoint1 = 48.148598,
  [FromQuery] double lonPoint1 = 17.107748,
  [FromQuery] double latPoint2 = 49.148598,
  [FromQuery] double lonPoint2 = 18.107748,
  [FromQuery] double gridSquareInDeg = 0.05)
{
  var result = await _context.GetShopsGridHeatMap(latPoint1, lonPoint1, latPoint2, lonPoint2, gridSquareInDeg);

  return Ok(result);
}
```
</details>

Now we need to do the Web App part. This is the first time we will load some data from our Api, so we will need to add HttpClient import and parameter in constructor. We will add this on top of the class:
```js
import { HttpClient, HttpParams } from '@angular/common/http';
```
And then add HttpClient paramter to constructor:
```js
constructor(private http: HttpClient) {}
```
We will add new method. Eventually this method will add 'shops' layer and source. To do that, we much check if the map already has this source and layer, and if yes, remove it:
```js
  protected getShopsHeatMap(): void {
    if (this.map == undefined) return;
    if (this.map.getSource('shops')) {
      this.map.removeLayer('shops');
      this.map.removeSource('shops');
    }
}
```
Now we need to call our Api for geojson. Geojson is already prepared by PostGis query. We can prepare separate method that will be called in callback when request to our Api completes and this method will add source and layer:
```js
protected addHeatMap(shops: string): void {
  if (this.map == undefined) {
    return;
  }

this.map.addSource('shops', {
        'type': 'geojson',
        'data': shops
        });

this.map.addLayer({
  'id': 'shops',
  'type': 'fill',
  'source': 'shops',
  'layout': {},
  'paint': {
    'fill-color': [
    'interpolate',
    ['linear'],
    ['get', 'count'],
    0,
    '#F2F12D',
    5,
    '#EED322',
    7,
    '#E6B71E',
    10,
    '#DA9C20',
    25,
    '#CA8323',
    50,
    '#B86B25',
    75,
    '#A25626',
    100,
    '#8B4225',
    250,
    '#723122'
    ],
    'fill-opacity': [
      'interpolate',
      ['linear'],
      ['get', 'count'],
      0, 0, 5, 0.5
    ]
    }
  });
}
```
This may look a bit daunting, but it is taking advantage of thing we already learned. ['get', 'count'] is used to retrieve count of shops for each square geometry. Pairs of count values and colors are interpolations for given shop counts, similar to multiple sizes for circle we used previously. And same is true for interpolating transparency.  

To finish code we need to retrieve corners of the map view, which can be done by calling map.getBounds().getSouthWest() and .getNorthEast. We need diagonally oposing corners. Then you need to execute http request, which looks like this:
```js
var bounds = this.map.getBounds();
var p1 = bounds.getSouthWest();
var p2 = bounds.getNorthEast();
var options = { params: new HttpParams()
  .append('latPoint1', p1.lat.toString())
  .append('lonPoint1', p1.lng.toString())
  .append('latPoint2', p2.lat.toString())
  .append('lonPoint2', p2.lng.toString())
  .append('gridSquareInDeg', this.widthInDeg)
}
this.http.get<string>('api/osm/GetShopsHeatMap', options).subscribe(this.addHeatMap);
```

Last step is to add button to the webpage that allows us to call this method:
```html
<div class="col">
  <div class="row mt-1">
    <button (click)="getShopsHeatMap()">Shops heatmap</button>
  </div>
  <div class="row mt-1">
    <input type="number" id="widthInDeg" name="widthInDeg" [(ngModel)]="widthInDeg" />
  </div>
</div>
```

Final result looks like this, but you can choose your own colors and transparency:  
![image](https://github.com/dpastierovic/Geospatial-Application/assets/18383754/2b1d69d7-44a4-457d-b2c9-f4a16008c94b)
## 6.2 Point style heatmap
Point style heatmap requires geometry of multiple points with numeric parameter that will be used as heat. MapBox provides special type of layer to generate heatmap automatically for this type of source. For this type, we won't do complete example but you can do it if you want as an exercise. Getting data to web application is similar to last example. Heatmap layer looks like this (example from [here](https://docs.mapbox.com/mapbox-gl-js/example/heatmap-layer/), and comments are next to each part to explain how it works:
```js
this.map.addLayer(
{
  'id': 'earthquakes-heat',
  'type': 'heatmap',
  'source': 'earthquakes',
  'maxzoom': 9,
  'paint': {
    // Increase the heatmap weight based on frequency and property magnitude
    'heatmap-weight': [
    'interpolate',
    ['linear'],
    ['get', 'mag'],
    0,
    0,
    6,
    1
    ],
    // Increase the heatmap color weight weight by zoom level
    // heatmap-intensity is a multiplier on top of heatmap-weight
    'heatmap-intensity': [
      'interpolate',
      ['linear'],
      ['zoom'],
      0,
      1,
      9,
      3
      ],
    // Color ramp for heatmap.  Domain is 0 (low) to 1 (high).
    // Begin color ramp at 0-stop with a 0-transparancy color
    // to create a blur-like effect.
    'heatmap-color': [
      'interpolate',
      ['linear'],
      ['heatmap-density'],
      0,
      'rgba(33,102,172,0)',
      0.2,
      'rgb(103,169,207)',
      0.4,
      'rgb(209,229,240)',
      0.6,
      'rgb(253,219,199)',
      0.8,
      'rgb(239,138,98)',
      1,
      'rgb(178,24,43)'
    ],
    // Adjust the heatmap radius by zoom level
    'heatmap-radius': [
    'interpolate',
    ['linear'],
    ['zoom'],
    0,
    2,
    9,
    20
    ],
    // Transition from heatmap to circle layer by zoom level
    'heatmap-opacity': [
      'interpolate',
      ['linear'],
      ['zoom'],
      7,
      1,
      9,
      0
      ]
    }
  },
  'waterway-label'
);
```
This type of heatmap calculates heat around circle in certain radius, then for each point calculates total heat from all points in range and color given point based on sum of the heat. Final result looks like this:  
![image](https://github.com/dpastierovic/Geospatial-Application/assets/18383754/7c6a6837-18c1-47a8-a58b-895bb2d39691)  
## 6.3 Line style heatmap
This type of heatmap can be simple to generate. You can just set lines to transparent and multiple overlaying lines will be less transparent that fewer. This creates non-transparent lines where heat is high, and near transparent lines where heat is low. It has its limitations though. You are limited to one color and only transparency as means to display heat. This is insufficient for heat map that wants to display for example trafic density. To do that, you need to pair each line to existing road and set heat of each road specifically. There is also relatively simple way to map non-precise gps recorded positions to streets which they passed. MapBox provides [public MapMatching API](https://docs.mapbox.com/api/navigation/map-matching/). You pass recorded gps in json format and get geojson with most probable route the user took. This can be used to increase heat of actual road instead of imprecise records jumping to places where road does not exists. Heatmap using this technique looks like Google Maps traffic map.
## 6.3 Final performance tips
- Use feature collections with single source and single layer. This allows use of heatmap type layers and has **massively** better performance than adding each geometry as new source and layer.
- If your heatmap grid is really complex, you can generate image from the data and overlay it over map. Displaying single image is much less perfomance exhausting that many geometries.
